
# Access many cells using slicing
#cell_range = ws['A1':'C2']


#Ranges of rows accessed
#colC = ws['C']
#col_range = ws['C:D']
#row10 = ws[10]
#row_range = ws[5:10]

#Iterating rows also by...
#You can also use the openpyxl.worksheet.Worksheet.iter_rows() method:
# for row in ws.iter_rows(min_row=1, max_col=3, max_row=2):
#...    for cell in row:
#...        print(cell)


#Iterating over columns...
#Likewise the openpyxl.worksheet.Worksheet.iter_cols() method will return columns:
#for col in ws.iter_cols(min_row=1, max_col=3, max_row=2):
#...     for cell in col:
#...         print(cell)

#Or this function, going from cell a1 to c9
#If you need to iterate through all the rows or columns of a file, you can instead use the openpyxl.worksheet.Worksheet.rows() property:
#ws = wb.active
#ws['C9'] = 'hello world'
#tuple(ws.rows)

#Or this function:
#or the openpyxl.worksheet.Worksheet.columns() property:
#tuple(ws.columns)


from openpyxl import workbook, load_workbook
wb = load_workbook(filename='test.xlsx')
ws = wb['Sheet1']

import sqlite3 as lite
import sys
conn = lite.connect('test.db')
cur = con.cursor()

for row in ws.get_squared_range(ws.min_column, ws.min_row + 1, ws.max_column, ws.max_row):
            placeholders = []
            vals = []
            for cell in row:
                placeholders.append('?')
                vals.append(cell.value)
            sql = 'INSERT INTO records (' + ','.join(db_fields) + ') VALUES (' + ','.join(placeholders[:len(db_fields)]) + ')'
            try:
                conn.execute(sql, tuple(vals[:len(db_fields)])) # make sure only db_fields number of columns
            except sqlite3.InterfaceError as e:
                print(e, file=sys.stderr)







